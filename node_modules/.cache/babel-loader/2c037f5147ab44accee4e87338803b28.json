{"ast":null,"code":"import { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, useReducer, useEffect, useRef } from 'react';\nconst ReactSharedInternals = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\nconst ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n\nconst useForceUpdate = () => useReducer(() => ({}))[1];\n\nconst notImplemented = name => () => {\n  const msg = `Hook \"${name}\" no possible to using inside useBetween scope.`;\n  console.error(msg);\n  throw new Error(msg);\n};\n\nconst equals = (a, b) => Object.is(a, b);\n\nconst shouldUpdate = (a, b) => !a || !b || a.length !== b.length || a.some((dep, index) => !equals(dep, b[index]));\n\nconst detectServer = () => typeof window === 'undefined';\n\nconst instances = new Map();\nlet boxes = [];\nlet pointer = 0;\nlet useEffectQueue = [];\nlet useLayoutEffectQueue = [];\n\nlet nextTick = () => {};\n\nlet isServer = detectServer();\nlet initialData = undefined;\n\nconst nextBox = () => {\n  const index = pointer++;\n  return boxes[index] = boxes[index] || {};\n};\n\nconst ownDisptacher = {\n  useState(initialState) {\n    const box = nextBox();\n    const tick = nextTick;\n\n    if (!box.initialized) {\n      box.state = typeof initialState === \"function\" ? initialState() : initialState;\n\n      box.set = fn => {\n        if (typeof fn === 'function') {\n          return box.set(fn(box.state));\n        }\n\n        if (!equals(fn, box.state)) {\n          box.state = fn;\n          tick();\n        }\n      };\n\n      box.initialized = true;\n    }\n\n    return [box.state, box.set];\n  },\n\n  useReducer(reducer, initialState, init) {\n    const box = nextBox();\n    const tick = nextTick;\n\n    if (!box.initialized) {\n      box.state = init ? init(initialState) : initialState;\n\n      box.dispatch = action => {\n        const state = reducer(box.state, action);\n\n        if (!equals(state, box.state)) {\n          box.state = state;\n          tick();\n        }\n      };\n\n      box.initialized = true;\n    }\n\n    return [box.state, box.dispatch];\n  },\n\n  useEffect(fn, deps) {\n    if (isServer) return;\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.initialized = true;\n      useEffectQueue.push([box, deps, fn]);\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      useEffectQueue.push([box, deps, fn]);\n    }\n  },\n\n  useLayoutEffect(fn, deps) {\n    if (isServer) return;\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.initialized = true;\n      useLayoutEffectQueue.push([box, deps, fn]);\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      useLayoutEffectQueue.push([box, deps, fn]);\n    }\n  },\n\n  useCallback(fn, deps) {\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.fn = fn;\n      box.deps = deps;\n      box.initialized = true;\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      box.fn = fn;\n    }\n\n    return box.fn;\n  },\n\n  useMemo(fn, deps) {\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.state = fn();\n      box.initialized = true;\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      box.state = fn();\n    }\n\n    return box.state;\n  },\n\n  useRef(initialValue) {\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.state = {\n        current: initialValue\n      };\n      box.initialized = true;\n    }\n\n    return box.state;\n  },\n\n  useImperativeHandle(ref, fn, deps) {\n    if (isServer) return;\n    const box = nextBox();\n\n    if (!box.initialized) {\n      box.deps = deps;\n      box.initialized = true;\n      useLayoutEffectQueue.push([box, deps, () => {\n        typeof ref === 'function' ? ref(fn()) : ref.current = fn();\n      }]);\n    } else if (shouldUpdate(box.deps, deps)) {\n      box.deps = deps;\n      useLayoutEffectQueue.push([box, deps, () => {\n        typeof ref === 'function' ? ref(fn()) : ref.current = fn();\n      }]);\n    }\n  }\n\n};\n['readContext', 'useContext', 'useDebugValue', 'useResponder', 'useDeferredValue', 'useTransition'].forEach(key => ownDisptacher[key] = notImplemented(key));\n\nconst factory = hook => {\n  const scopedBoxes = [];\n  let syncs = [];\n  let state = undefined;\n  let unsubs = [];\n\n  const sync = () => {\n    syncs.slice().forEach(fn => fn());\n  };\n\n  const tick = () => {\n    const originDispatcher = ReactCurrentDispatcher.current;\n    const originState = [pointer, useEffectQueue, useLayoutEffectQueue, boxes, nextTick];\n    let tickAgain = false;\n    let tickBody = true;\n    pointer = 0;\n    useEffectQueue = [];\n    useLayoutEffectQueue = [];\n    boxes = scopedBoxes;\n\n    nextTick = () => {\n      if (tickBody) {\n        tickAgain = true;\n      } else {\n        tick();\n      }\n    };\n\n    ReactCurrentDispatcher.current = ownDisptacher;\n    state = hook(initialData);\n    [useLayoutEffectQueue, useEffectQueue].forEach(queue => queue.forEach(([box, deps, fn]) => {\n      box.deps = deps;\n\n      if (box.unsub) {\n        const unsub = box.unsub;\n        unsubs = unsubs.filter(fn => fn !== unsub);\n        unsub();\n      }\n\n      const unsub = fn();\n\n      if (typeof unsub === \"function\") {\n        unsubs.push(unsub);\n        box.ubsub = unsub;\n      } else {\n        box.unsub = null;\n      }\n    }));\n    [pointer, useEffectQueue, useLayoutEffectQueue, boxes, nextTick] = originState;\n    ReactCurrentDispatcher.current = originDispatcher;\n    tickBody = false;\n\n    if (!tickAgain) {\n      sync();\n      return;\n    }\n\n    tick();\n  };\n\n  const sub = fn => {\n    syncs.push(fn);\n  };\n\n  const free = () => {\n    unsubs.slice().forEach(fn => fn());\n    instances.delete(hook);\n  };\n\n  const unsub = fn => {\n    syncs = syncs.filter(f => f !== fn);\n\n    if (syncs.length === 0) {\n      free();\n    }\n  };\n\n  return {\n    init: () => tick(),\n    get: () => state,\n    sub,\n    unsub\n  };\n};\n\nconst useBetween = hook => {\n  const forceUpdate = useForceUpdate();\n  let inst = instances.get(hook);\n\n  if (!inst) {\n    inst = factory(hook);\n    instances.set(hook, inst);\n    inst.init();\n  }\n\n  useEffect(() => (inst.sub(forceUpdate), () => inst.unsub(forceUpdate)), [inst]);\n  return inst.get();\n};\n\nconst useInitial = (data, server) => {\n  const ref = useRef();\n\n  if (!ref.current) {\n    isServer = typeof server === 'undefined' ? detectServer() : server;\n    isServer && instances.clear();\n    initialData = data;\n    ref.current = 1;\n  }\n};\n\nexport { useBetween, useInitial };","map":{"version":3,"sources":["/home/leland/MLPractice/snp-lamp-design-client/node_modules/use-between/release/index.esm.js"],"names":["__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","useReducer","useEffect","useRef","ReactSharedInternals","ReactCurrentDispatcher","useForceUpdate","notImplemented","name","msg","console","error","Error","equals","a","b","Object","is","shouldUpdate","length","some","dep","index","detectServer","window","instances","Map","boxes","pointer","useEffectQueue","useLayoutEffectQueue","nextTick","isServer","initialData","undefined","nextBox","ownDisptacher","useState","initialState","box","tick","initialized","state","set","fn","reducer","init","dispatch","action","deps","push","useLayoutEffect","useCallback","useMemo","initialValue","current","useImperativeHandle","ref","forEach","key","factory","hook","scopedBoxes","syncs","unsubs","sync","slice","originDispatcher","originState","tickAgain","tickBody","queue","unsub","filter","ubsub","sub","free","delete","f","get","useBetween","forceUpdate","inst","useInitial","data","server","clear"],"mappings":"AAAA,SAASA,kDAAT,EAA6DC,UAA7D,EAAyEC,SAAzE,EAAoFC,MAApF,QAAkG,OAAlG;AAEA,MAAMC,oBAAoB,GAAGJ,kDAA7B;AACA,MAAMK,sBAAsB,GAAGD,oBAAoB,CAACC,sBAApD;;AAEA,MAAMC,cAAc,GAAG,MAAML,UAAU,CAAC,OAAO,EAAP,CAAD,CAAV,CAAuB,CAAvB,CAA7B;;AAEA,MAAMM,cAAc,GAAIC,IAAD,IAAU,MAAM;AACnC,QAAMC,GAAG,GAAI,SAAQD,IAAK,iDAA1B;AACAE,EAAAA,OAAO,CAACC,KAAR,CAAcF,GAAd;AACA,QAAM,IAAIG,KAAJ,CAAUH,GAAV,CAAN;AACH,CAJD;;AAKA,MAAMI,MAAM,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAUC,MAAM,CAACC,EAAP,CAAUH,CAAV,EAAaC,CAAb,CAAzB;;AACA,MAAMG,YAAY,GAAG,CAACJ,CAAD,EAAIC,CAAJ,KAAY,CAACD,CAAD,IAAM,CAACC,CAAR,IAC3BD,CAAC,CAACK,MAAF,KAAaJ,CAAC,CAACI,MADY,IAE5BL,CAAC,CAACM,IAAF,CAAO,CAACC,GAAD,EAAMC,KAAN,KAAgB,CAACT,MAAM,CAACQ,GAAD,EAAMN,CAAC,CAACO,KAAD,CAAP,CAA9B,CAFJ;;AAGA,MAAMC,YAAY,GAAG,MAAM,OAAOC,MAAP,KAAkB,WAA7C;;AACA,MAAMC,SAAS,GAAG,IAAIC,GAAJ,EAAlB;AACA,IAAIC,KAAK,GAAG,EAAZ;AACA,IAAIC,OAAO,GAAG,CAAd;AACA,IAAIC,cAAc,GAAG,EAArB;AACA,IAAIC,oBAAoB,GAAG,EAA3B;;AACA,IAAIC,QAAQ,GAAG,MAAM,CAAG,CAAxB;;AACA,IAAIC,QAAQ,GAAGT,YAAY,EAA3B;AACA,IAAIU,WAAW,GAAGC,SAAlB;;AACA,MAAMC,OAAO,GAAG,MAAM;AAClB,QAAMb,KAAK,GAAGM,OAAO,EAArB;AACA,SAAQD,KAAK,CAACL,KAAD,CAAL,GAAeK,KAAK,CAACL,KAAD,CAAL,IAAgB,EAAvC;AACH,CAHD;;AAIA,MAAMc,aAAa,GAAG;AAClBC,EAAAA,QAAQ,CAACC,YAAD,EAAe;AACnB,UAAMC,GAAG,GAAGJ,OAAO,EAAnB;AACA,UAAMK,IAAI,GAAGT,QAAb;;AACA,QAAI,CAACQ,GAAG,CAACE,WAAT,EAAsB;AAClBF,MAAAA,GAAG,CAACG,KAAJ,GAAY,OAAOJ,YAAP,KAAwB,UAAxB,GAAqCA,YAAY,EAAjD,GAAsDA,YAAlE;;AACAC,MAAAA,GAAG,CAACI,GAAJ,GAAWC,EAAD,IAAQ;AACd,YAAI,OAAOA,EAAP,KAAc,UAAlB,EAA8B;AAC1B,iBAAOL,GAAG,CAACI,GAAJ,CAAQC,EAAE,CAACL,GAAG,CAACG,KAAL,CAAV,CAAP;AACH;;AACD,YAAI,CAAC7B,MAAM,CAAC+B,EAAD,EAAKL,GAAG,CAACG,KAAT,CAAX,EAA4B;AACxBH,UAAAA,GAAG,CAACG,KAAJ,GAAYE,EAAZ;AACAJ,UAAAA,IAAI;AACP;AACJ,OARD;;AASAD,MAAAA,GAAG,CAACE,WAAJ,GAAkB,IAAlB;AACH;;AACD,WAAO,CAACF,GAAG,CAACG,KAAL,EAAYH,GAAG,CAACI,GAAhB,CAAP;AACH,GAlBiB;;AAmBlB1C,EAAAA,UAAU,CAAC4C,OAAD,EAAUP,YAAV,EAAwBQ,IAAxB,EAA8B;AACpC,UAAMP,GAAG,GAAGJ,OAAO,EAAnB;AACA,UAAMK,IAAI,GAAGT,QAAb;;AACA,QAAI,CAACQ,GAAG,CAACE,WAAT,EAAsB;AAClBF,MAAAA,GAAG,CAACG,KAAJ,GAAYI,IAAI,GAAGA,IAAI,CAACR,YAAD,CAAP,GAAwBA,YAAxC;;AACAC,MAAAA,GAAG,CAACQ,QAAJ,GAAgBC,MAAD,IAAY;AACvB,cAAMN,KAAK,GAAGG,OAAO,CAACN,GAAG,CAACG,KAAL,EAAYM,MAAZ,CAArB;;AACA,YAAI,CAACnC,MAAM,CAAC6B,KAAD,EAAQH,GAAG,CAACG,KAAZ,CAAX,EAA+B;AAC3BH,UAAAA,GAAG,CAACG,KAAJ,GAAYA,KAAZ;AACAF,UAAAA,IAAI;AACP;AACJ,OAND;;AAOAD,MAAAA,GAAG,CAACE,WAAJ,GAAkB,IAAlB;AACH;;AACD,WAAO,CAACF,GAAG,CAACG,KAAL,EAAYH,GAAG,CAACQ,QAAhB,CAAP;AACH,GAlCiB;;AAmClB7C,EAAAA,SAAS,CAAC0C,EAAD,EAAKK,IAAL,EAAW;AAChB,QAAIjB,QAAJ,EACI;AACJ,UAAMO,GAAG,GAAGJ,OAAO,EAAnB;;AACA,QAAI,CAACI,GAAG,CAACE,WAAT,EAAsB;AAClBF,MAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;AACAV,MAAAA,GAAG,CAACE,WAAJ,GAAkB,IAAlB;AACAZ,MAAAA,cAAc,CAACqB,IAAf,CAAoB,CAACX,GAAD,EAAMU,IAAN,EAAYL,EAAZ,CAApB;AACH,KAJD,MAKK,IAAI1B,YAAY,CAACqB,GAAG,CAACU,IAAL,EAAWA,IAAX,CAAhB,EAAkC;AACnCV,MAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;AACApB,MAAAA,cAAc,CAACqB,IAAf,CAAoB,CAACX,GAAD,EAAMU,IAAN,EAAYL,EAAZ,CAApB;AACH;AACJ,GAhDiB;;AAiDlBO,EAAAA,eAAe,CAACP,EAAD,EAAKK,IAAL,EAAW;AACtB,QAAIjB,QAAJ,EACI;AACJ,UAAMO,GAAG,GAAGJ,OAAO,EAAnB;;AACA,QAAI,CAACI,GAAG,CAACE,WAAT,EAAsB;AAClBF,MAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;AACAV,MAAAA,GAAG,CAACE,WAAJ,GAAkB,IAAlB;AACAX,MAAAA,oBAAoB,CAACoB,IAArB,CAA0B,CAACX,GAAD,EAAMU,IAAN,EAAYL,EAAZ,CAA1B;AACH,KAJD,MAKK,IAAI1B,YAAY,CAACqB,GAAG,CAACU,IAAL,EAAWA,IAAX,CAAhB,EAAkC;AACnCV,MAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;AACAnB,MAAAA,oBAAoB,CAACoB,IAArB,CAA0B,CAACX,GAAD,EAAMU,IAAN,EAAYL,EAAZ,CAA1B;AACH;AACJ,GA9DiB;;AA+DlBQ,EAAAA,WAAW,CAACR,EAAD,EAAKK,IAAL,EAAW;AAClB,UAAMV,GAAG,GAAGJ,OAAO,EAAnB;;AACA,QAAI,CAACI,GAAG,CAACE,WAAT,EAAsB;AAClBF,MAAAA,GAAG,CAACK,EAAJ,GAASA,EAAT;AACAL,MAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;AACAV,MAAAA,GAAG,CAACE,WAAJ,GAAkB,IAAlB;AACH,KAJD,MAKK,IAAIvB,YAAY,CAACqB,GAAG,CAACU,IAAL,EAAWA,IAAX,CAAhB,EAAkC;AACnCV,MAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;AACAV,MAAAA,GAAG,CAACK,EAAJ,GAASA,EAAT;AACH;;AACD,WAAOL,GAAG,CAACK,EAAX;AACH,GA3EiB;;AA4ElBS,EAAAA,OAAO,CAACT,EAAD,EAAKK,IAAL,EAAW;AACd,UAAMV,GAAG,GAAGJ,OAAO,EAAnB;;AACA,QAAI,CAACI,GAAG,CAACE,WAAT,EAAsB;AAClBF,MAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;AACAV,MAAAA,GAAG,CAACG,KAAJ,GAAYE,EAAE,EAAd;AACAL,MAAAA,GAAG,CAACE,WAAJ,GAAkB,IAAlB;AACH,KAJD,MAKK,IAAIvB,YAAY,CAACqB,GAAG,CAACU,IAAL,EAAWA,IAAX,CAAhB,EAAkC;AACnCV,MAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;AACAV,MAAAA,GAAG,CAACG,KAAJ,GAAYE,EAAE,EAAd;AACH;;AACD,WAAOL,GAAG,CAACG,KAAX;AACH,GAxFiB;;AAyFlBvC,EAAAA,MAAM,CAACmD,YAAD,EAAe;AACjB,UAAMf,GAAG,GAAGJ,OAAO,EAAnB;;AACA,QAAI,CAACI,GAAG,CAACE,WAAT,EAAsB;AAClBF,MAAAA,GAAG,CAACG,KAAJ,GAAY;AAAEa,QAAAA,OAAO,EAAED;AAAX,OAAZ;AACAf,MAAAA,GAAG,CAACE,WAAJ,GAAkB,IAAlB;AACH;;AACD,WAAOF,GAAG,CAACG,KAAX;AACH,GAhGiB;;AAiGlBc,EAAAA,mBAAmB,CAACC,GAAD,EAAMb,EAAN,EAAUK,IAAV,EAAgB;AAC/B,QAAIjB,QAAJ,EACI;AACJ,UAAMO,GAAG,GAAGJ,OAAO,EAAnB;;AACA,QAAI,CAACI,GAAG,CAACE,WAAT,EAAsB;AAClBF,MAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;AACAV,MAAAA,GAAG,CAACE,WAAJ,GAAkB,IAAlB;AACAX,MAAAA,oBAAoB,CAACoB,IAArB,CAA0B,CAACX,GAAD,EAAMU,IAAN,EAAY,MAAM;AACpC,eAAOQ,GAAP,KAAe,UAAf,GAA4BA,GAAG,CAACb,EAAE,EAAH,CAA/B,GAAwCa,GAAG,CAACF,OAAJ,GAAcX,EAAE,EAAxD;AACH,OAFqB,CAA1B;AAGH,KAND,MAOK,IAAI1B,YAAY,CAACqB,GAAG,CAACU,IAAL,EAAWA,IAAX,CAAhB,EAAkC;AACnCV,MAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;AACAnB,MAAAA,oBAAoB,CAACoB,IAArB,CAA0B,CAACX,GAAD,EAAMU,IAAN,EAAY,MAAM;AACpC,eAAOQ,GAAP,KAAe,UAAf,GAA4BA,GAAG,CAACb,EAAE,EAAH,CAA/B,GAAwCa,GAAG,CAACF,OAAJ,GAAcX,EAAE,EAAxD;AACH,OAFqB,CAA1B;AAGH;AACJ;;AAlHiB,CAAtB;AAoHA,CACI,aADJ,EAEI,YAFJ,EAGI,eAHJ,EAII,cAJJ,EAKI,kBALJ,EAMI,eANJ,EAOEc,OAPF,CAOUC,GAAG,IAAIvB,aAAa,CAACuB,GAAD,CAAb,GAAqBpD,cAAc,CAACoD,GAAD,CAPpD;;AAQA,MAAMC,OAAO,GAAIC,IAAD,IAAU;AACtB,QAAMC,WAAW,GAAG,EAApB;AACA,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIrB,KAAK,GAAGR,SAAZ;AACA,MAAI8B,MAAM,GAAG,EAAb;;AACA,QAAMC,IAAI,GAAG,MAAM;AACfF,IAAAA,KAAK,CAACG,KAAN,GAAcR,OAAd,CAAsBd,EAAE,IAAIA,EAAE,EAA9B;AACH,GAFD;;AAGA,QAAMJ,IAAI,GAAG,MAAM;AACf,UAAM2B,gBAAgB,GAAG9D,sBAAsB,CAACkD,OAAhD;AACA,UAAMa,WAAW,GAAG,CAChBxC,OADgB,EAEhBC,cAFgB,EAGhBC,oBAHgB,EAIhBH,KAJgB,EAKhBI,QALgB,CAApB;AAOA,QAAIsC,SAAS,GAAG,KAAhB;AACA,QAAIC,QAAQ,GAAG,IAAf;AACA1C,IAAAA,OAAO,GAAG,CAAV;AACAC,IAAAA,cAAc,GAAG,EAAjB;AACAC,IAAAA,oBAAoB,GAAG,EAAvB;AACAH,IAAAA,KAAK,GAAGmC,WAAR;;AACA/B,IAAAA,QAAQ,GAAG,MAAM;AACb,UAAIuC,QAAJ,EAAc;AACVD,QAAAA,SAAS,GAAG,IAAZ;AACH,OAFD,MAGK;AACD7B,QAAAA,IAAI;AACP;AACJ,KAPD;;AAQAnC,IAAAA,sBAAsB,CAACkD,OAAvB,GAAiCnB,aAAjC;AACAM,IAAAA,KAAK,GAAGmB,IAAI,CAAC5B,WAAD,CAAZ;AACA,KAACH,oBAAD,EAAuBD,cAAvB,EAAuC6B,OAAvC,CAA+Ca,KAAK,IAAKA,KAAK,CAACb,OAAN,CAAc,CAAC,CAACnB,GAAD,EAAMU,IAAN,EAAYL,EAAZ,CAAD,KAAqB;AACxFL,MAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;;AACA,UAAIV,GAAG,CAACiC,KAAR,EAAe;AACX,cAAMA,KAAK,GAAGjC,GAAG,CAACiC,KAAlB;AACAR,QAAAA,MAAM,GAAGA,MAAM,CAACS,MAAP,CAAc7B,EAAE,IAAIA,EAAE,KAAK4B,KAA3B,CAAT;AACAA,QAAAA,KAAK;AACR;;AACD,YAAMA,KAAK,GAAG5B,EAAE,EAAhB;;AACA,UAAI,OAAO4B,KAAP,KAAiB,UAArB,EAAiC;AAC7BR,QAAAA,MAAM,CAACd,IAAP,CAAYsB,KAAZ;AACAjC,QAAAA,GAAG,CAACmC,KAAJ,GAAYF,KAAZ;AACH,OAHD,MAIK;AACDjC,QAAAA,GAAG,CAACiC,KAAJ,GAAY,IAAZ;AACH;AACJ,KAfwD,CAAzD;AAgBA,KACI5C,OADJ,EAEIC,cAFJ,EAGIC,oBAHJ,EAIIH,KAJJ,EAKII,QALJ,IAMIqC,WANJ;AAOA/D,IAAAA,sBAAsB,CAACkD,OAAvB,GAAiCY,gBAAjC;AACAG,IAAAA,QAAQ,GAAG,KAAX;;AACA,QAAI,CAACD,SAAL,EAAgB;AACZJ,MAAAA,IAAI;AACJ;AACH;;AACDzB,IAAAA,IAAI;AACP,GAvDD;;AAwDA,QAAMmC,GAAG,GAAI/B,EAAD,IAAQ;AAChBmB,IAAAA,KAAK,CAACb,IAAN,CAAWN,EAAX;AACH,GAFD;;AAGA,QAAMgC,IAAI,GAAG,MAAM;AACfZ,IAAAA,MAAM,CAACE,KAAP,GAAeR,OAAf,CAAuBd,EAAE,IAAIA,EAAE,EAA/B;AACAnB,IAAAA,SAAS,CAACoD,MAAV,CAAiBhB,IAAjB;AACH,GAHD;;AAIA,QAAMW,KAAK,GAAI5B,EAAD,IAAQ;AAClBmB,IAAAA,KAAK,GAAGA,KAAK,CAACU,MAAN,CAAaK,CAAC,IAAIA,CAAC,KAAKlC,EAAxB,CAAR;;AACA,QAAImB,KAAK,CAAC5C,MAAN,KAAiB,CAArB,EAAwB;AACpByD,MAAAA,IAAI;AACP;AACJ,GALD;;AAMA,SAAO;AACH9B,IAAAA,IAAI,EAAE,MAAMN,IAAI,EADb;AAEHuC,IAAAA,GAAG,EAAE,MAAMrC,KAFR;AAGHiC,IAAAA,GAHG;AAIHH,IAAAA;AAJG,GAAP;AAMH,CAnFD;;AAoFA,MAAMQ,UAAU,GAAInB,IAAD,IAAU;AACzB,QAAMoB,WAAW,GAAG3E,cAAc,EAAlC;AACA,MAAI4E,IAAI,GAAGzD,SAAS,CAACsD,GAAV,CAAclB,IAAd,CAAX;;AACA,MAAI,CAACqB,IAAL,EAAW;AACPA,IAAAA,IAAI,GAAGtB,OAAO,CAACC,IAAD,CAAd;AACApC,IAAAA,SAAS,CAACkB,GAAV,CAAckB,IAAd,EAAoBqB,IAApB;AACAA,IAAAA,IAAI,CAACpC,IAAL;AACH;;AACD5C,EAAAA,SAAS,CAAC,OAAOgF,IAAI,CAACP,GAAL,CAASM,WAAT,GAAuB,MAAMC,IAAI,CAACV,KAAL,CAAWS,WAAX,CAApC,CAAD,EAA+D,CAACC,IAAD,CAA/D,CAAT;AACA,SAAOA,IAAI,CAACH,GAAL,EAAP;AACH,CAVD;;AAWA,MAAMI,UAAU,GAAG,CAACC,IAAD,EAAOC,MAAP,KAAkB;AACjC,QAAM5B,GAAG,GAAGtD,MAAM,EAAlB;;AACA,MAAI,CAACsD,GAAG,CAACF,OAAT,EAAkB;AACdvB,IAAAA,QAAQ,GAAG,OAAOqD,MAAP,KAAkB,WAAlB,GAAgC9D,YAAY,EAA5C,GAAiD8D,MAA5D;AACArD,IAAAA,QAAQ,IAAIP,SAAS,CAAC6D,KAAV,EAAZ;AACArD,IAAAA,WAAW,GAAGmD,IAAd;AACA3B,IAAAA,GAAG,CAACF,OAAJ,GAAc,CAAd;AACH;AACJ,CARD;;AAUA,SAASyB,UAAT,EAAqBG,UAArB","sourcesContent":["import { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, useReducer, useEffect, useRef } from 'react';\n\nconst ReactSharedInternals = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\nconst ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n\nconst useForceUpdate = () => useReducer(() => ({}))[1];\n\nconst notImplemented = (name) => () => {\r\n    const msg = `Hook \"${name}\" no possible to using inside useBetween scope.`;\r\n    console.error(msg);\r\n    throw new Error(msg);\r\n};\r\nconst equals = (a, b) => Object.is(a, b);\r\nconst shouldUpdate = (a, b) => ((!a || !b) ||\r\n    (a.length !== b.length) ||\r\n    a.some((dep, index) => !equals(dep, b[index])));\r\nconst detectServer = () => typeof window === 'undefined';\r\nconst instances = new Map();\r\nlet boxes = [];\r\nlet pointer = 0;\r\nlet useEffectQueue = [];\r\nlet useLayoutEffectQueue = [];\r\nlet nextTick = () => { };\r\nlet isServer = detectServer();\r\nlet initialData = undefined;\r\nconst nextBox = () => {\r\n    const index = pointer++;\r\n    return (boxes[index] = boxes[index] || {});\r\n};\r\nconst ownDisptacher = {\r\n    useState(initialState) {\r\n        const box = nextBox();\r\n        const tick = nextTick;\r\n        if (!box.initialized) {\r\n            box.state = typeof initialState === \"function\" ? initialState() : initialState;\r\n            box.set = (fn) => {\r\n                if (typeof fn === 'function') {\r\n                    return box.set(fn(box.state));\r\n                }\r\n                if (!equals(fn, box.state)) {\r\n                    box.state = fn;\r\n                    tick();\r\n                }\r\n            };\r\n            box.initialized = true;\r\n        }\r\n        return [box.state, box.set];\r\n    },\r\n    useReducer(reducer, initialState, init) {\r\n        const box = nextBox();\r\n        const tick = nextTick;\r\n        if (!box.initialized) {\r\n            box.state = init ? init(initialState) : initialState;\r\n            box.dispatch = (action) => {\r\n                const state = reducer(box.state, action);\r\n                if (!equals(state, box.state)) {\r\n                    box.state = state;\r\n                    tick();\r\n                }\r\n            };\r\n            box.initialized = true;\r\n        }\r\n        return [box.state, box.dispatch];\r\n    },\r\n    useEffect(fn, deps) {\r\n        if (isServer)\r\n            return;\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n            useEffectQueue.push([box, deps, fn]);\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            useEffectQueue.push([box, deps, fn]);\r\n        }\r\n    },\r\n    useLayoutEffect(fn, deps) {\r\n        if (isServer)\r\n            return;\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n            useLayoutEffectQueue.push([box, deps, fn]);\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            useLayoutEffectQueue.push([box, deps, fn]);\r\n        }\r\n    },\r\n    useCallback(fn, deps) {\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.fn = fn;\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            box.fn = fn;\r\n        }\r\n        return box.fn;\r\n    },\r\n    useMemo(fn, deps) {\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.state = fn();\r\n            box.initialized = true;\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            box.state = fn();\r\n        }\r\n        return box.state;\r\n    },\r\n    useRef(initialValue) {\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.state = { current: initialValue };\r\n            box.initialized = true;\r\n        }\r\n        return box.state;\r\n    },\r\n    useImperativeHandle(ref, fn, deps) {\r\n        if (isServer)\r\n            return;\r\n        const box = nextBox();\r\n        if (!box.initialized) {\r\n            box.deps = deps;\r\n            box.initialized = true;\r\n            useLayoutEffectQueue.push([box, deps, () => {\r\n                    typeof ref === 'function' ? ref(fn()) : ref.current = fn();\r\n                }]);\r\n        }\r\n        else if (shouldUpdate(box.deps, deps)) {\r\n            box.deps = deps;\r\n            useLayoutEffectQueue.push([box, deps, () => {\r\n                    typeof ref === 'function' ? ref(fn()) : ref.current = fn();\r\n                }]);\r\n        }\r\n    }\r\n};\r\n[\r\n    'readContext',\r\n    'useContext',\r\n    'useDebugValue',\r\n    'useResponder',\r\n    'useDeferredValue',\r\n    'useTransition'\r\n].forEach(key => ownDisptacher[key] = notImplemented(key));\r\nconst factory = (hook) => {\r\n    const scopedBoxes = [];\r\n    let syncs = [];\r\n    let state = undefined;\r\n    let unsubs = [];\r\n    const sync = () => {\r\n        syncs.slice().forEach(fn => fn());\r\n    };\r\n    const tick = () => {\r\n        const originDispatcher = ReactCurrentDispatcher.current;\r\n        const originState = [\r\n            pointer,\r\n            useEffectQueue,\r\n            useLayoutEffectQueue,\r\n            boxes,\r\n            nextTick\r\n        ];\r\n        let tickAgain = false;\r\n        let tickBody = true;\r\n        pointer = 0;\r\n        useEffectQueue = [];\r\n        useLayoutEffectQueue = [];\r\n        boxes = scopedBoxes;\r\n        nextTick = () => {\r\n            if (tickBody) {\r\n                tickAgain = true;\r\n            }\r\n            else {\r\n                tick();\r\n            }\r\n        };\r\n        ReactCurrentDispatcher.current = ownDisptacher;\r\n        state = hook(initialData);\r\n        [useLayoutEffectQueue, useEffectQueue].forEach(queue => (queue.forEach(([box, deps, fn]) => {\r\n            box.deps = deps;\r\n            if (box.unsub) {\r\n                const unsub = box.unsub;\r\n                unsubs = unsubs.filter(fn => fn !== unsub);\r\n                unsub();\r\n            }\r\n            const unsub = fn();\r\n            if (typeof unsub === \"function\") {\r\n                unsubs.push(unsub);\r\n                box.ubsub = unsub;\r\n            }\r\n            else {\r\n                box.unsub = null;\r\n            }\r\n        })));\r\n        [\r\n            pointer,\r\n            useEffectQueue,\r\n            useLayoutEffectQueue,\r\n            boxes,\r\n            nextTick\r\n        ] = originState;\r\n        ReactCurrentDispatcher.current = originDispatcher;\r\n        tickBody = false;\r\n        if (!tickAgain) {\r\n            sync();\r\n            return;\r\n        }\r\n        tick();\r\n    };\r\n    const sub = (fn) => {\r\n        syncs.push(fn);\r\n    };\r\n    const free = () => {\r\n        unsubs.slice().forEach(fn => fn());\r\n        instances.delete(hook);\r\n    };\r\n    const unsub = (fn) => {\r\n        syncs = syncs.filter(f => f !== fn);\r\n        if (syncs.length === 0) {\r\n            free();\r\n        }\r\n    };\r\n    return {\r\n        init: () => tick(),\r\n        get: () => state,\r\n        sub,\r\n        unsub,\r\n    };\r\n};\r\nconst useBetween = (hook) => {\r\n    const forceUpdate = useForceUpdate();\r\n    let inst = instances.get(hook);\r\n    if (!inst) {\r\n        inst = factory(hook);\r\n        instances.set(hook, inst);\r\n        inst.init();\r\n    }\r\n    useEffect(() => (inst.sub(forceUpdate), () => inst.unsub(forceUpdate)), [inst]);\r\n    return inst.get();\r\n};\r\nconst useInitial = (data, server) => {\r\n    const ref = useRef();\r\n    if (!ref.current) {\r\n        isServer = typeof server === 'undefined' ? detectServer() : server;\r\n        isServer && instances.clear();\r\n        initialData = data;\r\n        ref.current = 1;\r\n    }\r\n};\n\nexport { useBetween, useInitial };\n"]},"metadata":{},"sourceType":"module"}